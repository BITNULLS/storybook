-- Generated by Oracle SQL Developer Data Modeler 21.4.1.349.1605
--   at:        2022-03-03 17:10:49 EST
--   site:      Oracle Database 12cR2
--   type:      Oracle Database 12cR2



CREATE TABLESPACE data 
--  WARNING: Tablespace has no data files defined 
 LOGGING ONLINE
    EXTENT MANAGEMENT LOCAL AUTOALLOCATE
FLASHBACK ON;

CREATE USER kpelster IDENTIFIED BY ACCOUNT UNLOCK ;

-- predefined type, no DDL - MDSYS.SDO_GEOMETRY

-- predefined type, no DDL - XMLTYPE

CREATE TABLE kpelster.action (
    user_id      VARCHAR2(32 BYTE) NOT NULL,
    action_start DATE NOT NULL,
    action_stop  DATE NOT NULL,
    book_id      NUMBER NOT NULL,
    detail_id    NUMBER NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;


CREATE TABLE KPELSTER.ACTION_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,USER_ID VARCHAR2 (32 BYTE) NOT NULL
 ,ACTION_START DATE NOT NULL
 ,ACTION_STOP DATE NOT NULL
 ,BOOK_ID NUMBER NOT NULL
 ,DETAIL_ID NUMBER NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.ACTION_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.ACTION for each row 
 Declare 
  rec KPELSTER.ACTION_JN%ROWTYPE; 
  blank KPELSTER.ACTION_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.USER_ID := :NEW.USER_ID; 
      rec.ACTION_START := :NEW.ACTION_START; 
      rec.ACTION_STOP := :NEW.ACTION_STOP; 
      rec.BOOK_ID := :NEW.BOOK_ID; 
      rec.DETAIL_ID := :NEW.DETAIL_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.USER_ID := :OLD.USER_ID; 
      rec.ACTION_START := :OLD.ACTION_START; 
      rec.ACTION_STOP := :OLD.ACTION_STOP; 
      rec.BOOK_ID := :OLD.BOOK_ID; 
      rec.DETAIL_ID := :OLD.DETAIL_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.ACTION_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.action_detail (
    detail_id          NUMBER NOT NULL,
    detail_description VARCHAR2(100 BYTE) NOT NULL,
    action_key_id      NUMBER NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;

CREATE UNIQUE INDEX kpelster.action_detail_pk ON
    kpelster.action_detail (
        detail_id
    ASC )
        TABLESPACE data PCTFREE 10 INITRANS 20
            STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
            DEFAULT )
        LOGGING;

ALTER TABLE kpelster.action_detail
    ADD CONSTRAINT action_detail_pk PRIMARY KEY ( detail_id )
        USING INDEX kpelster.action_detail_pk;


CREATE TABLE KPELSTER.ACTION_DETAIL_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,DETAIL_ID NUMBER NOT NULL
 ,DETAIL_DESCRIPTION VARCHAR2 (100 BYTE) NOT NULL
 ,ACTION_KEY_ID NUMBER NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.ACTION_DETAIL_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.ACTION_DETAIL for each row 
 Declare 
  rec KPELSTER.ACTION_DETAIL_JN%ROWTYPE; 
  blank KPELSTER.ACTION_DETAIL_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.DETAIL_ID := :NEW.DETAIL_ID; 
      rec.DETAIL_DESCRIPTION := :NEW.DETAIL_DESCRIPTION; 
      rec.ACTION_KEY_ID := :NEW.ACTION_KEY_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.DETAIL_ID := :OLD.DETAIL_ID; 
      rec.DETAIL_DESCRIPTION := :OLD.DETAIL_DESCRIPTION; 
      rec.ACTION_KEY_ID := :OLD.ACTION_KEY_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.ACTION_DETAIL_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.action_key (
    action_key_id NUMBER NOT NULL,
    action_name   VARCHAR2(32 BYTE) NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;

CREATE UNIQUE INDEX kpelster.action_key_pk ON
    kpelster.action_key (
        action_key_id
    ASC )
        TABLESPACE data PCTFREE 10 INITRANS 20
            STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
            DEFAULT )
        LOGGING;

ALTER TABLE kpelster.action_key
    ADD CONSTRAINT action_key_pk PRIMARY KEY ( action_key_id )
        USING INDEX kpelster.action_key_pk;


CREATE TABLE KPELSTER.ACTION_KEY_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ACTION_KEY_ID NUMBER NOT NULL
 ,ACTION_NAME VARCHAR2 (32 BYTE) NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.ACTION_KEY_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.ACTION_KEY for each row 
 Declare 
  rec KPELSTER.ACTION_KEY_JN%ROWTYPE; 
  blank KPELSTER.ACTION_KEY_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ACTION_KEY_ID := :NEW.ACTION_KEY_ID; 
      rec.ACTION_NAME := :NEW.ACTION_NAME; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ACTION_KEY_ID := :OLD.ACTION_KEY_ID; 
      rec.ACTION_NAME := :OLD.ACTION_NAME; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.ACTION_KEY_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.answer (
    answer_id   NUMBER NOT NULL,
    question_id NUMBER NOT NULL,
    answer      VARCHAR2(1000 BYTE) NOT NULL,
    correct     NUMBER NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;

CREATE UNIQUE INDEX kpelster.answer_pk ON
    kpelster.answer (
        answer_id
    ASC )
        TABLESPACE data PCTFREE 10 INITRANS 20
            STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
            DEFAULT )
        LOGGING;

ALTER TABLE kpelster.answer
    ADD CONSTRAINT answer_pk PRIMARY KEY ( answer_id )
        USING INDEX kpelster.answer_pk;


CREATE TABLE KPELSTER.ANSWER_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ANSWER_ID NUMBER NOT NULL
 ,QUESTION_ID NUMBER NOT NULL
 ,ANSWER VARCHAR2 (1000 BYTE) NOT NULL
 ,CORRECT NUMBER NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.ANSWER_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.ANSWER for each row 
 Declare 
  rec KPELSTER.ANSWER_JN%ROWTYPE; 
  blank KPELSTER.ANSWER_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ANSWER_ID := :NEW.ANSWER_ID; 
      rec.QUESTION_ID := :NEW.QUESTION_ID; 
      rec.ANSWER := :NEW.ANSWER; 
      rec.CORRECT := :NEW.CORRECT; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ANSWER_ID := :OLD.ANSWER_ID; 
      rec.QUESTION_ID := :OLD.QUESTION_ID; 
      rec.ANSWER := :OLD.ANSWER; 
      rec.CORRECT := :OLD.CORRECT; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.ANSWER_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.book (
    book_id     NUMBER NOT NULL,
    book_name   VARCHAR2(20 BYTE) NOT NULL,
    created_on  DATE NOT NULL,
    url         VARCHAR2(20 BYTE),
    description VARCHAR2(1000 BYTE) NOT NULL,
    page_count  NUMBER NOT NULL,
    folder      VARCHAR2(100 BYTE) NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;

CREATE UNIQUE INDEX kpelster.book_pk ON
    kpelster.book (
        book_id
    ASC )
        TABLESPACE data PCTFREE 10 INITRANS 20
            STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
            DEFAULT )
        LOGGING;

ALTER TABLE kpelster.book
    ADD CONSTRAINT book_pk PRIMARY KEY ( book_id )
        USING INDEX kpelster.book_pk;


CREATE TABLE KPELSTER.BOOK_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,BOOK_ID NUMBER NOT NULL
 ,BOOK_NAME VARCHAR2 (20 BYTE) NOT NULL
 ,CREATED_ON DATE NOT NULL
 ,URL VARCHAR2 (20 BYTE)
 ,DESCRIPTION VARCHAR2 (1000 BYTE) NOT NULL
 ,PAGE_COUNT NUMBER NOT NULL
 ,FOLDER VARCHAR2 (100 BYTE) NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.BOOK_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.BOOK for each row 
 Declare 
  rec KPELSTER.BOOK_JN%ROWTYPE; 
  blank KPELSTER.BOOK_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.BOOK_ID := :NEW.BOOK_ID; 
      rec.BOOK_NAME := :NEW.BOOK_NAME; 
      rec.CREATED_ON := :NEW.CREATED_ON; 
      rec.URL := :NEW.URL; 
      rec.DESCRIPTION := :NEW.DESCRIPTION; 
      rec.PAGE_COUNT := :NEW.PAGE_COUNT; 
      rec.FOLDER := :NEW.FOLDER; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.BOOK_ID := :OLD.BOOK_ID; 
      rec.BOOK_NAME := :OLD.BOOK_NAME; 
      rec.CREATED_ON := :OLD.CREATED_ON; 
      rec.URL := :OLD.URL; 
      rec.DESCRIPTION := :OLD.DESCRIPTION; 
      rec.PAGE_COUNT := :OLD.PAGE_COUNT; 
      rec.FOLDER := :OLD.FOLDER; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.BOOK_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.book_study (
    book_id  NUMBER NOT NULL,
    study_id NUMBER NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS UNLIMITED FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;


CREATE TABLE KPELSTER.BOOK_STUDY_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,BOOK_ID NUMBER NOT NULL
 ,STUDY_ID NUMBER NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.BOOK_STUDY_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.BOOK_STUDY for each row 
 Declare 
  rec KPELSTER.BOOK_STUDY_JN%ROWTYPE; 
  blank KPELSTER.BOOK_STUDY_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.BOOK_ID := :NEW.BOOK_ID; 
      rec.STUDY_ID := :NEW.STUDY_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.BOOK_ID := :OLD.BOOK_ID; 
      rec.STUDY_ID := :OLD.STUDY_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.BOOK_STUDY_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.password_reset (
    user_id      VARCHAR2(36 BYTE) NOT NULL,
    reset_key    VARCHAR2(1024 BYTE) NOT NULL,
    request_date DATE NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;


CREATE TABLE KPELSTER.PASSWORD_RESET_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,USER_ID VARCHAR2 (36 BYTE) NOT NULL
 ,RESET_KEY VARCHAR2 (1024 BYTE) NOT NULL
 ,REQUEST_DATE DATE NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.PASSWORD_RESET_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.PASSWORD_RESET for each row 
 Declare 
  rec KPELSTER.PASSWORD_RESET_JN%ROWTYPE; 
  blank KPELSTER.PASSWORD_RESET_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.USER_ID := :NEW.USER_ID; 
      rec.RESET_KEY := :NEW.RESET_KEY; 
      rec.REQUEST_DATE := :NEW.REQUEST_DATE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.USER_ID := :OLD.USER_ID; 
      rec.RESET_KEY := :OLD.RESET_KEY; 
      rec.REQUEST_DATE := :OLD.REQUEST_DATE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.PASSWORD_RESET_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.question (
    question_id   NUMBER NOT NULL,
    school_id     NUMBER NOT NULL,
    book_id       NUMBER NOT NULL,
    question      VARCHAR2(1000 BYTE) NOT NULL,
    page_prev     NUMBER NOT NULL,
    page_next     NUMBER NOT NULL,
    question_type NUMBER NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;

CREATE UNIQUE INDEX kpelster.question_pk ON
    kpelster.question (
        question_id
    ASC )
        TABLESPACE data PCTFREE 10 INITRANS 20
            STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
            DEFAULT )
        LOGGING;

ALTER TABLE kpelster.question
    ADD CONSTRAINT question_pk PRIMARY KEY ( question_id )
        USING INDEX kpelster.question_pk;


CREATE TABLE KPELSTER.QUESTION_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,QUESTION_ID NUMBER NOT NULL
 ,SCHOOL_ID NUMBER NOT NULL
 ,BOOK_ID NUMBER NOT NULL
 ,QUESTION VARCHAR2 (1000 BYTE) NOT NULL
 ,PAGE_PREV NUMBER NOT NULL
 ,PAGE_NEXT NUMBER NOT NULL
 ,QUESTION_TYPE NUMBER NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.QUESTION_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.QUESTION for each row 
 Declare 
  rec KPELSTER.QUESTION_JN%ROWTYPE; 
  blank KPELSTER.QUESTION_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.QUESTION_ID := :NEW.QUESTION_ID; 
      rec.SCHOOL_ID := :NEW.SCHOOL_ID; 
      rec.BOOK_ID := :NEW.BOOK_ID; 
      rec.QUESTION := :NEW.QUESTION; 
      rec.PAGE_PREV := :NEW.PAGE_PREV; 
      rec.PAGE_NEXT := :NEW.PAGE_NEXT; 
      rec.QUESTION_TYPE := :NEW.QUESTION_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.QUESTION_ID := :OLD.QUESTION_ID; 
      rec.SCHOOL_ID := :OLD.SCHOOL_ID; 
      rec.BOOK_ID := :OLD.BOOK_ID; 
      rec.QUESTION := :OLD.QUESTION; 
      rec.PAGE_PREV := :OLD.PAGE_PREV; 
      rec.PAGE_NEXT := :OLD.PAGE_NEXT; 
      rec.QUESTION_TYPE := :OLD.QUESTION_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.QUESTION_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.school (
    school_id   NUMBER NOT NULL,
    school_name VARCHAR2(40 BYTE) NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;

CREATE UNIQUE INDEX kpelster.school_pk ON
    kpelster.school (
        school_id
    ASC )
        TABLESPACE data PCTFREE 10 INITRANS 20
            STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
            DEFAULT )
        LOGGING;

ALTER TABLE kpelster.school
    ADD CONSTRAINT school_pk PRIMARY KEY ( school_id )
        USING INDEX kpelster.school_pk;


CREATE TABLE KPELSTER.SCHOOL_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,SCHOOL_ID NUMBER NOT NULL
 ,SCHOOL_NAME VARCHAR2 (40 BYTE) NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.SCHOOL_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.SCHOOL for each row 
 Declare 
  rec KPELSTER.SCHOOL_JN%ROWTYPE; 
  blank KPELSTER.SCHOOL_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.SCHOOL_ID := :NEW.SCHOOL_ID; 
      rec.SCHOOL_NAME := :NEW.SCHOOL_NAME; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.SCHOOL_ID := :OLD.SCHOOL_ID; 
      rec.SCHOOL_NAME := :OLD.SCHOOL_NAME; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.SCHOOL_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.study (
    study_id   NUMBER NOT NULL,
    school_id  NUMBER NOT NULL,
    study_name VARCHAR2(40 BYTE) NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;

CREATE UNIQUE INDEX kpelster.study_pk ON
    kpelster.study (
        study_id
    ASC )
        TABLESPACE data PCTFREE 10 INITRANS 20
            STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
            DEFAULT )
        LOGGING;

ALTER TABLE kpelster.study
    ADD CONSTRAINT study_pk PRIMARY KEY ( study_id )
        USING INDEX kpelster.study_pk;


CREATE TABLE KPELSTER.STUDY_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,STUDY_ID NUMBER NOT NULL
 ,SCHOOL_ID NUMBER NOT NULL
 ,STUDY_NAME VARCHAR2 (40 BYTE) NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.STUDY_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.STUDY for each row 
 Declare 
  rec KPELSTER.STUDY_JN%ROWTYPE; 
  blank KPELSTER.STUDY_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.STUDY_ID := :NEW.STUDY_ID; 
      rec.SCHOOL_ID := :NEW.SCHOOL_ID; 
      rec.STUDY_NAME := :NEW.STUDY_NAME; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.STUDY_ID := :OLD.STUDY_ID; 
      rec.SCHOOL_ID := :OLD.SCHOOL_ID; 
      rec.STUDY_NAME := :OLD.STUDY_NAME; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.STUDY_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.user_profile (
    email      VARCHAR2(50 BYTE) NOT NULL,
    first_name VARCHAR2(20 BYTE) NOT NULL,
    last_name  VARCHAR2(20 BYTE) NOT NULL,
    admin      NUMBER NOT NULL,
    school_id  NUMBER NOT NULL,
    created_on DATE NOT NULL,
    last_login DATE,
    password   VARCHAR2(60 BYTE) NOT NULL,
    user_id    VARCHAR2(36 BYTE) NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;

CREATE UNIQUE INDEX kpelster.user_profile_pk ON
    kpelster.user_profile (
        user_id
    ASC )
        TABLESPACE data PCTFREE 10 INITRANS 20
            STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
            DEFAULT )
        LOGGING;

ALTER TABLE kpelster.user_profile
    ADD CONSTRAINT user_profile_pk PRIMARY KEY ( user_id )
        USING INDEX kpelster.user_profile_pk;


CREATE TABLE KPELSTER.USER_PROFILE_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,EMAIL VARCHAR2 (50 BYTE) NOT NULL
 ,FIRST_NAME VARCHAR2 (20 BYTE) NOT NULL
 ,LAST_NAME VARCHAR2 (20 BYTE) NOT NULL
 ,ADMIN NUMBER NOT NULL
 ,SCHOOL_ID NUMBER NOT NULL
 ,CREATED_ON DATE NOT NULL
 ,LAST_LOGIN DATE
 ,PASSWORD VARCHAR2 (60 BYTE) NOT NULL
 ,USER_ID VARCHAR2 (36 BYTE) NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.USER_PROFILE_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.USER_PROFILE for each row 
 Declare 
  rec KPELSTER.USER_PROFILE_JN%ROWTYPE; 
  blank KPELSTER.USER_PROFILE_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.EMAIL := :NEW.EMAIL; 
      rec.FIRST_NAME := :NEW.FIRST_NAME; 
      rec.LAST_NAME := :NEW.LAST_NAME; 
      rec.ADMIN := :NEW.ADMIN; 
      rec.SCHOOL_ID := :NEW.SCHOOL_ID; 
      rec.CREATED_ON := :NEW.CREATED_ON; 
      rec.LAST_LOGIN := :NEW.LAST_LOGIN; 
      rec.PASSWORD := :NEW.PASSWORD; 
      rec.USER_ID := :NEW.USER_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.EMAIL := :OLD.EMAIL; 
      rec.FIRST_NAME := :OLD.FIRST_NAME; 
      rec.LAST_NAME := :OLD.LAST_NAME; 
      rec.ADMIN := :OLD.ADMIN; 
      rec.SCHOOL_ID := :OLD.SCHOOL_ID; 
      rec.CREATED_ON := :OLD.CREATED_ON; 
      rec.LAST_LOGIN := :OLD.LAST_LOGIN; 
      rec.PASSWORD := :OLD.PASSWORD; 
      rec.USER_ID := :OLD.USER_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.USER_PROFILE_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.user_response (
    user_id     VARCHAR2(32 BYTE) NOT NULL,
    question_id NUMBER NOT NULL,
    answer_id   NUMBER NOT NULL,
    answered_on DATE NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;


CREATE TABLE KPELSTER.USER_RESPONSE_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,USER_ID VARCHAR2 (32 BYTE) NOT NULL
 ,QUESTION_ID NUMBER NOT NULL
 ,ANSWER_ID NUMBER NOT NULL
 ,ANSWERED_ON DATE NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.USER_RESPONSE_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.USER_RESPONSE for each row 
 Declare 
  rec KPELSTER.USER_RESPONSE_JN%ROWTYPE; 
  blank KPELSTER.USER_RESPONSE_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.USER_ID := :NEW.USER_ID; 
      rec.QUESTION_ID := :NEW.QUESTION_ID; 
      rec.ANSWER_ID := :NEW.ANSWER_ID; 
      rec.ANSWERED_ON := :NEW.ANSWERED_ON; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.USER_ID := :OLD.USER_ID; 
      rec.QUESTION_ID := :OLD.QUESTION_ID; 
      rec.ANSWER_ID := :OLD.ANSWER_ID; 
      rec.ANSWERED_ON := :OLD.ANSWERED_ON; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.USER_RESPONSE_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.user_session (
    session_id VARCHAR2(36 BYTE) NOT NULL,
    user_id    VARCHAR2(36 BYTE) NOT NULL,
    last_login DATE NOT NULL,
    active     NUMBER(1) DEFAULT 0 NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;

CREATE UNIQUE INDEX kpelster.user_session_index1 ON
    kpelster.user_session (
        session_id
    ASC )
        TABLESPACE data PCTFREE 10 INITRANS 20
            STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
            DEFAULT )
        LOGGING;

ALTER TABLE kpelster.user_session
    ADD CONSTRAINT user_session_pk PRIMARY KEY ( session_id )
        USING INDEX kpelster.user_session_index1;


CREATE TABLE KPELSTER.USER_SESSION_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,SESSION_ID VARCHAR2 (36 BYTE) NOT NULL
 ,USER_ID VARCHAR2 (36 BYTE) NOT NULL
 ,LAST_LOGIN DATE NOT NULL
 ,ACTIVE NUMBER (1) NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.USER_SESSION_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.USER_SESSION for each row 
 Declare 
  rec KPELSTER.USER_SESSION_JN%ROWTYPE; 
  blank KPELSTER.USER_SESSION_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.SESSION_ID := :NEW.SESSION_ID; 
      rec.USER_ID := :NEW.USER_ID; 
      rec.LAST_LOGIN := :NEW.LAST_LOGIN; 
      rec.ACTIVE := :NEW.ACTIVE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.SESSION_ID := :OLD.SESSION_ID; 
      rec.USER_ID := :OLD.USER_ID; 
      rec.LAST_LOGIN := :OLD.LAST_LOGIN; 
      rec.ACTIVE := :OLD.ACTIVE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.USER_SESSION_JN VALUES rec; 
  END; 
  /CREATE TABLE kpelster.user_study (
    user_id  VARCHAR2(32 BYTE) NOT NULL,
    study_id NUMBER NOT NULL
)
PCTFREE 10 PCTUSED 40 INITRANS 10 TABLESPACE data LOGGING
    STORAGE ( INITIAL 65536 NEXT 1048576 PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS 2147483645 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT )
NO INMEMORY;


CREATE TABLE KPELSTER.USER_STUDY_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,USER_ID VARCHAR2 (32 BYTE) NOT NULL
 ,STUDY_ID NUMBER NOT NULL
 );

CREATE OR REPLACE TRIGGER KPELSTER.USER_STUDY_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON KPELSTER.USER_STUDY for each row 
 Declare 
  rec KPELSTER.USER_STUDY_JN%ROWTYPE; 
  blank KPELSTER.USER_STUDY_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.USER_ID := :NEW.USER_ID; 
      rec.STUDY_ID := :NEW.STUDY_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.USER_ID := :OLD.USER_ID; 
      rec.STUDY_ID := :OLD.STUDY_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into KPELSTER.USER_STUDY_JN VALUES rec; 
  END; 
  /ALTER TABLE kpelster.action
    ADD CONSTRAINT action_book_fk FOREIGN KEY ( book_id )
        REFERENCES kpelster.book ( book_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.action_detail
    ADD CONSTRAINT action_detail_action_id_fk FOREIGN KEY ( action_key_id )
        REFERENCES kpelster.action_key ( action_key_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.action
    ADD CONSTRAINT action_detail_id FOREIGN KEY ( detail_id )
        REFERENCES kpelster.action_detail ( detail_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.answer
    ADD CONSTRAINT answer_question_fk FOREIGN KEY ( question_id )
        REFERENCES kpelster.question ( question_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.book_study
    ADD CONSTRAINT book_study_fk1 FOREIGN KEY ( book_id )
        REFERENCES kpelster.book ( book_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.book_study
    ADD CONSTRAINT book_study_fk2 FOREIGN KEY ( study_id )
        REFERENCES kpelster.study ( study_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.password_reset
    ADD CONSTRAINT password_reset_user_id_fk FOREIGN KEY ( user_id )
        REFERENCES kpelster.user_profile ( user_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.question
    ADD CONSTRAINT question_book_id FOREIGN KEY ( book_id )
        REFERENCES kpelster.book ( book_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.question
    ADD CONSTRAINT question_school_id_fk FOREIGN KEY ( school_id )
        REFERENCES kpelster.school ( school_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.study
    ADD CONSTRAINT study_school_id_fk FOREIGN KEY ( school_id )
        REFERENCES kpelster.school ( school_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.user_profile
    ADD CONSTRAINT user_profile_school_id_fk FOREIGN KEY ( school_id )
        REFERENCES kpelster.school ( school_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.user_response
    ADD CONSTRAINT user_response_answer_id_fk FOREIGN KEY ( answer_id )
        REFERENCES kpelster.answer ( answer_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.user_response
    ADD CONSTRAINT user_response_question_id_fk FOREIGN KEY ( question_id )
        REFERENCES kpelster.question ( question_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.user_session
    ADD CONSTRAINT user_session_fk1 FOREIGN KEY ( user_id )
        REFERENCES kpelster.user_profile ( user_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.user_study
    ADD CONSTRAINT user_study_study_id_fk FOREIGN KEY ( study_id )
        REFERENCES kpelster.study ( study_id )
    NOT DEFERRABLE;

ALTER TABLE kpelster.user_study
    ADD CONSTRAINT user_study_user_id_fk FOREIGN KEY ( user_id )
        REFERENCES kpelster.user_profile ( user_id )
    NOT DEFERRABLE;

CREATE OR REPLACE TRIGGER KPELSTER.ANSWER_TRG 
    BEFORE INSERT ON KPELSTER.ANSWER 
    FOR EACH ROW 
BEGIN
    SELECT ANSWER_SEQ.NEXTVAL INTO :new.ANSWER_ID FROM dual;
  NULL;
END; 
/

CREATE OR REPLACE TRIGGER KPELSTER.BOOK_TRG 
    BEFORE INSERT ON KPELSTER.BOOK 
    FOR EACH ROW 
BEGIN

    SELECT BOOK_SEQ.NEXTVAL INTO :new.BOOK_ID FROM dual;
    :new.CREATED_ON := sysdate();
    
  NULL;
END; 
/

CREATE OR REPLACE TRIGGER KPELSTER.DETAIL_ID_TRG 
    BEFORE INSERT ON KPELSTER.ACTION_DETAIL 
    FOR EACH ROW 
BEGIN
    SELECT DETAILS_SEQ.NEXTVAL INTO :new.DETAIL_ID FROM dual;
  NULL;
END; 
/

CREATE OR REPLACE TRIGGER KPELSTER.NEW_USER_SESSION 
    AFTER INSERT ON KPELSTER.USER_PROFILE 
    FOR EACH ROW 
DECLARE 
    v_random_session_id raw(32);
BEGIN
  -- When a new user is created, it automatically has a new user_session created
  select sys_guid() into v_random_session_id from dual;
  v_random_session_id := RAWTOHEX(v_random_session_id);

    IF inserting THEN
        INSERT INTO user_session (
            session_id,
            user_id,
            last_login,
            active
        ) VALUES (
            v_random_session_id,
            :new.user_id,
            sysdate,
            0
        );

    END IF;
END; 
/

CREATE OR REPLACE TRIGGER KPELSTER.PASSWORD_RESET_TRG 
    BEFORE INSERT ON KPELSTER.PASSWORD_RESET 
    FOR EACH ROW 
declare
        t_user_id password_reset.user_id%type;
        user_exists EXCEPTION;
        PRAGMA exception_init(user_exists, -20100);
        id_count number;
BEGIN
        select count(*) into id_count from password_reset where user_id = :new.user_id;
        
        if id_count > 0 then
            raise_application_error(-20100, 'User already has entry.');
        end if;
        
        :new.request_date := sysdate;
   
END; 
/

CREATE OR REPLACE TRIGGER KPELSTER.QUESTION_TRG 
    BEFORE INSERT ON KPELSTER.QUESTION 
    FOR EACH ROW 
BEGIN
    SELECT QUESTION_SEQ.NEXTVAL INTO :new.QUESTION_ID FROM dual;
  NULL;
END; 
/

CREATE OR REPLACE TRIGGER KPELSTER.SCHOOL_TRG 
    BEFORE INSERT ON KPELSTER.SCHOOL 
    FOR EACH ROW 
BEGIN
    SELECT SCHOOL_SEQ.NEXTVAL INTO :new.SCHOOL_ID FROM dual;
  NULL;
END; 
/

CREATE OR REPLACE TRIGGER KPELSTER.STUDY_TRG 
    BEFORE INSERT ON KPELSTER.STUDY 
    FOR EACH ROW 
BEGIN
    SELECT STUDY_SEQ.NEXTVAL INTO :new.STUDY_ID FROM dual;
  NULL;
END; 
/

CREATE OR REPLACE TRIGGER KPELSTER.USER_ID_TRG 
    BEFORE INSERT ON KPELSTER.USER_PROFILE 
    FOR EACH ROW 
BEGIN
    select sys_guid() into :new.user_id from dual;
  NULL; 
END; 
/

CREATE OR REPLACE TRIGGER KPELSTER.USER_PROFILE_CREATED_ON 
    BEFORE INSERT ON KPELSTER.USER_PROFILE 
    FOR EACH ROW 
BEGIN
    :new.created_on := sysdate;
    
END; 
/



-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                            14
-- CREATE INDEX                             9
-- ALTER TABLE                             25
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                          10
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          0
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        1
-- CREATE USER                              1
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 1
